Vulnerability 1

1. Type: 
    Broken Authentication -- Week Password Patthern

2. Source Code and Root Cause:
    - Lines 46. The initial admin password list are all commonly used password that can be easily attacked by brute force.

3. How the Vulnerability Could be Exploited:

    There are two main methods to exploit this vulnerability:
    
    * Online Dictionary Attack:
        Attackers might use online dictionary attacks against the adminâ€™s account. They can try passwords from a list of commonly used password, as seen here: 

        https://en.wikipedia.org/wiki/List_of_the_most_common_passwords. 

        They can start with the most frequently used one, with three chances to guess the password right. Even though our application imposes a limit on login attempts, there is still a relatively high probability that attackers can guess the correct password.


    * Offline Dictionary Attack:
        Hackers can execute offline dictionary attacks once they obtain the admin's hashed password. This becomes feasible if database data is leaked, which is another vulnerability we will address later. Additionally, this web service uses MD5 (another vulnerability we will discuss), making it more susceptible to offline brute force attacks.

4. Impact of the Vulnerability:
    Hackers can exploit this vulnerability to employ offline dictionary attack and gain access to any users' account, including that of the admin. This could lead to the leak of user information as each user's messages are private. Furthermore, upon gaining admin access, hackers might exploit the web application even further. We will also discuss how to exploit this web app after have gained access to admin account later.

5. How the Vulnerability was Addressed:
    We should update every password in the initial list with a more intricate variant. Additionally, introducing salt and pepper to the authentication process will significantly bolster password complexity. It's also paramount to replace the outdated MD5 with a modern hashing function, a topic we'll delve into later.

    Furthermore, it's imperative not to hardcode passwords directly into source code. This presents a substantial risk, especially if malicious individuals gain access to our code repository. Doing so would directly provide attackers with a valid list of passwords, facilitating their dictionary attacks.

Vulnerability 2

1. Type: 
    Broken Authentication - Weak Hashing Algorithm

2. Source Code and Root Cause:
    Line 36: hsh = hashlib.md5(password.encode()).hexdigest() 

    The code employs the MD5 hash function for passwords. MD5 is known to be unsafe to bruteforce attakcs and is not suitable for production environments.

3. How the Vulnerability Could be Exploited:
    Attackers can exploit this vulnerability in conjunction with other security vulnerability to bypass authentication. For example, if attackers exploit another vulnerability to access the database, they can obtain the hashed passwords of all users. Subsequently, they can attempt to brute force these hashed passwords. The situation is exacerbated if the hacker also uses dictionary attacks, as highlighted in vulnerability 1, to accelerate the brute force process.

4. Impact of the Vulnerability:
    When combined with other vulnerabilities, this weakness can lead to significant user information leaks. Moreover, it might allow hackers to gain access to admin account, opening the door for even more severe attacks.

5. How the Vulnerability was Addressed:
    We can replace the MD5 algorithm with a more robust hashing algorithm such as Argon2 or another contemporary hash function.

Vulnerability 3

1. Type: Broken Access Control

2. Source Code and Root Cause:
    line 315: if len(s) != 2 

    The code is designed to validate the filename during a user's file download request. However, the code only verifies if the filename matches the user's name and neglects to check the file's extension for validity.

3. How the Vulnerability Could be Exploited:
    Hackers can exploit this oversight to access "database.db," a file containing messages and users' passwords. Here's a step-by-step breakdown:

    1. Hacker sign up a user named "database"
    2. Hacker login as the user "database"
    3. Hacker directly request api "http://localhost:80/download?file=database.db"

    Due to the code's logic, it only compares the username from the cookie to the filename (sans extension). This allows the hacker to directly access and download "database.db."

4. Impact of the Vulnerability:
    Once hackers access the database, they can retrieve all private user data. Additionally, given that the web server uses the weak MD5 hashing algorithm, it's relatively easy for attackers to brute force all the hashed passwords. This could potentially allow unauthorized access to all user accounts, including the admin account, thus hackers could use admin account for further exploitation.

5. How the Vulnerability was Addressed:
    
    Multiple mediation approaches exist:

        * File Extension Check: 
            This straightforward fix involves ensuring the file extension is either CSV or JSON, thereby mitigating the vulnerability.

        * Use of Signed Cookies to Store the Filename: 
            Typically, a user chooses a message format (CSV or JSON) before downloading. When user click download button, the server firstly generates the message file with chosen format. Then user can download the file based on the filename. The key point here is that we can ensure that message file generated by server is safe. Therefore we can ensure the download api is safe if user only can download the message file that generated by server. Therefore after server generated message file, we can set the safe filename in users cookie, and then referencing this cookie during the actual download, it removes opportunities for filename manipulation by malicious actors because the filename is signed by server.

Vulnerability 4

1. Type: Command injection 

2. Source Code and Root Cause:
    Line 147: os.system(f"rm -f {filename}")

    Line 147 uses the `os.system` method combined with string manipulation to remove files. This allows malicious actors an opportunity to inject commands for the filename.

3. How the Vulnerability Could be Exploited:
    To exploit this vulnerability and inject malicious code into the server's `app.html` file (altering the view for every user), attackers can:

    1. Obtain admin account access, as detailed in vulnerability 3.
    2. Send a POST request to `http://localhost:80/admin`, embedding the injected command within the form data. The form data is as below: 
        username: none; sed -i 's|<html>|<img src onerror="javascript:alert('\''Hacked!'\'')"\>|' templates/app.html #

        This username value will be userd in the formatted string in line 147, and the final commands that is execute by server is:

        os.system("rm -f none; sed -i 's|<html>|<img src onerror="javascript:alert('\''Hacked!'\'')"\>|' templates/app.html #.csv") 
            and
        os.system("rm -f none; sed -i 's|<html>|<img src onerror="javascript:alert('\''Hacked!'\'')"\>|' templates/app.html #.json") 

    The last file extension is added by server since the original code is to delete all the file of provided filename with json and csv extension.

    3. Ultimately, the executed command can add a malicious `<img>` HTML tag before the `<html>` tag. This triggers an alert for every user accessing the `app.html` file at the root endpoint.

4. Impact of the Vulnerability:

    This vulnerability allows command injection, which can perform any action that `system.os` can execute. The potential harm includes file deletion, data alteration, and even server container destruction.

5. How the Vulnerability was Addressed:
    We should not direclty use os.system to execute commands. We should use dedicated python library to safely delete a file. For instance, we can change line 147 to:

        os.remove(filename)

Vulnerability 5
1. Type:  
    Broken Authentication -- Command Injection

2. Source Code and Root Cause:
    Line 174: user = request.form['username']

    This line assigns the username directly from the form data. The username is then used in a manner that allows it to be executed directly by `system.os`, as referenced in vulnerability 4. Because this input is unsanitized, it introduces a command injection risk. Additionally, given that an administrator should not have direct command execution privileges on the server, it represents a broken authentication vulnerability.

3. How the Vulnerability Could be Exploited:
    The lack of input sanitization means that an attacker can leverage this vulnerability to execute command injection as detailed in vulnerability 4. The exploitation process mirrors that described for vulnerability 4.


4. Impact of the Vulnerability:
    Attackers exploiting this vulnerability can execute malicious commands. Potential outcomes include file deletion or alteration, as well as compromising the entire server container.



5. How the Vulnerability was Addressed:
    Directly utilizing the admin-provided username without any sanitization is dangerous. A preferable approach is to first verify the username against the database. Since we sanitize all usernames upon user registration, checking against this known list ensures that only sanitized usernames are used.

    We can add following codes:

        connection = sqlite3.connect("database.db")
        sql = "SELECT username,password,login_attempts FROM users WHERE username=?;"
        cursor = connection.cursor()
        cursor.execute(sql,[username])
        result = cursor.fetchall()
        connection.close()

        # Check whether the username is in database 
        if len(result) != 0: 
    By ensuring that the provided username matches an entry in the sanitized database, the vulnerability can be effectively mitigated.

Vulnerability 6
1. Type: Security Misconfiguration

2. Source Code and Root Cause:
    No source code since the security configuration for flask server is not configured. For example, the web server didn't configure csrf token to make sure that the form submission is always safe. Also since the web server didn't not add support for tls/https, there is no way to configure HSTS(Https Strict Transport Security) to enforce user using secured transmission protocal. Another important security configuration is to enable CSP(Content-Security-Policy) to disable requests from a iframe which can protect user from click hijacking. Overall this web application is lack of neccesssary security configuration.

3. How the Vulnerability Could be Exploited:
    There are multiple ways to exploit such web application without proper security configuration. We will give a instance where 

    For instance, we can make use of the fact that the site is not setting content security rules for iframe.

    Step 1: Hackers create a site and nested a iFrame to http://127.0.0.1:80/

    Step 2: Hackers hide this iFrame and cover the iFrame with a malicious button to trick users that clicking this button can win lottery

    Step 3: Send this malicious website to users

4. Impact of the Vulnerability:

    Security miconfiguration can trigger multiple types of serious attacks including CSFR, XSS, click hijacking and others. Eventhough our web application can use other machanism to make sure some of the attacks won't be exploited, it is important to configure these security configuration right as the first guard of web application. 


5. How the Vulnerability was Addressed:
    Firstly we can deploy https to enable secure transimission. Then we can add below codes to configure some basic secure policy for our flask server:

    @app.after_request
    def apply_caching(response):
        response.headers["X-XSS-Protection"] = "1; mode=block" 
        response.headers["X-Frame-Options"] = "SAMEORIGIN" 
        response.headers["X-Content-Type-Options"] = "nosniff" 
        response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains" 
        response.headers["Content-Security-Policy"] = "frame-ancestors 'self'; default-src 'self';"
        response.headers["Referrer-Policy"] = "strict-origin"
        return response    
    
    Above codes is mentioned in lecture slides and can provide basic configuration for iframe click hijacking, xss and enforce https.



Vulnerability 6

1. Type: Security Misconfiguration

2. Source Code and Root Cause:
    The vulnerability does not stem from source code; rather, it arises from a security misconfiguration of the Flask server. Specifically, the web server is not configured with a CSRF token, which would ensure the safety of form submissions. Additionally, because the web server does not support TLS/HTTPS, HSTS (HTTP Strict Transport Security) cannot be configured to enforce the use of a secure transmission protocol. Another essential security configuration missing is the CSP (Content-Security-Policy), which could protect users from click hijacking using iframe. In sum, the web application lacks necessary security configurations.

3. How the Vulnerability Could be Exploited:
    Such a web application, devoid of proper security configurations, is open to various forms of exploitation. For instance, the absence of content security rules for iframes can be manipulated as follows:

    - Step 1: Hackers create a website that nests an iframe pointing to `http://127.0.0.1:80/`.
    
    - Step 2: This iframe is concealed by hackers, overlaying it with a malicious button in the position of the button of account deletion. Unsuspecting users are led to believe that clicking this button could win them a lottery but actually delete their accounts.
    
    - Step 3: Hackers distribute this malicious website url to users by sending email or other ways.

4. Impact of the Vulnerability:
    A security misconfiguration can open the doors to a slew of critical attacks, encompassing CSRF, XSS, click hijacking, and more. Even if our web application employs other mechanisms to deter some of these attacks, setting up the correct security configurations is paramount as the first line of defense for a web application.

5. How the Vulnerability was Addressed:
    An immediate step would be to implement HTTPS, ensuring secure data transmission. Subsequently, the following code can be added to institute some foundational security policies for the Flask server:

    ```python
    @app.after_request
    def apply_caching(response):
        response.headers["X-XSS-Protection"] = "1; mode=block" 
        response.headers["X-Frame-Options"] = "SAMEORIGIN" 
        response.headers["X-Content-Type-Options"] = "nosniff" 
        response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains" 
        response.headers["Content-Security-Policy"] = "frame-ancestors 'self'; default-src 'self';"
        response.headers["Referrer-Policy"] = "strict-origin"
        return response
    ```

    This code is mentioned in lecture slides, can address potential iframe click hijacking, XSS attacks, and enforce HTTPS.
---
