Vulnerability 1

1. Type: 
    Broken Authentication -- Week Password Patthern

2. Source Code and Root Cause:
    - Lines 46. The initial admin password list are all commonly used password that can be easily attacked by brute force.

3. How the Vulnerability Could be Exploited:

    There are two main methods to exploit this vulnerability:
    
    * Online Dictionary Attack:
        Attackers might use online dictionary attacks against the adminâ€™s account. They can try passwords from a list of commonly used password, as seen here: 

        https://en.wikipedia.org/wiki/List_of_the_most_common_passwords. 

        They can start with the most frequently used one, with three chances to guess the password right. Even though our application imposes a limit on login attempts, there is still a relatively high probability that attackers can guess the correct password.


    * Offline Dictionary Attack:
        Hackers can execute offline dictionary attacks once they obtain the admin's hashed password. This becomes feasible if database data is leaked, which is another vulnerability we will address later. Additionally, this web service uses MD5 (another vulnerability we will discuss), making it more susceptible to offline brute force attacks.

4. Impact of the Vulnerability:
    Hackers can exploit this vulnerability to employ offline dictionary attack and gain access to any users' account, including that of the admin. This could lead to the leak of user information as each user's messages are private. Furthermore, upon gaining admin access, hackers might exploit the web application even further. We will also discuss how to exploit this web app after have gained access to admin account later.

5. How the Vulnerability was Addressed:
    We should update every password in the initial list with a more intricate variant. Additionally, introducing salt and pepper to the authentication process will significantly bolster password complexity. It's also paramount to replace the outdated MD5 with a modern hashing function, a topic we'll delve into later.

    Furthermore, it's imperative not to hardcode passwords directly into source code. This presents a substantial risk, especially if malicious individuals gain access to our code repository. Doing so would directly provide attackers with a valid list of passwords, facilitating their dictionary attacks.

Vulnerability 2

1. Type: 
    Broken Authentication - Weak Hashing Algorithm

2. Source Code and Root Cause:
    Line 36: hsh = hashlib.md5(password.encode()).hexdigest() 

    The code employs the MD5 hash function for passwords. MD5 is known to be unsafe to bruteforce attakcs and is not suitable for production environments.

3. How the Vulnerability Could be Exploited:
    Attackers can exploit this vulnerability in conjunction with other security vulnerability to bypass authentication. For example, if attackers exploit another vulnerability to access the database, they can obtain the hashed passwords of all users. Subsequently, they can attempt to brute force these hashed passwords. The situation is exacerbated if the hacker also uses dictionary attacks, as highlighted in vulnerability 1, to accelerate the brute force process.

4. Impact of the Vulnerability:
    When combined with other vulnerabilities, this weakness can lead to significant user information leaks. Moreover, it might allow hackers to gain access to admin account, opening the door for even more severe attacks.

5. How the Vulnerability was Addressed:
    We can replace the MD5 algorithm with a more robust hashing algorithm such as Argon2 or another contemporary hash function.

Vulnerability 3

1. Type: Broken Access Control

2. Source Code and Root Cause:
    line 315: if len(s) != 2 

    Here is the code when users needs to download files and server needs to validate whether the filename is valid. However, the code only examine whether the filename is the same as user, not examine whether the extension name is qualified.

3. How the Vulnerability Could be Exploited:
    Hackers can use this vulnerability to download "database.db" which is the file of database of messages and usernames. Below is the concrete steps:

    1. Hacker sign up a user named "database"
    2. Hacker login as the user "database"
    3. Hacker directly request api "http://localhost:80/download?file=database.db"

    Because the code here will only check whether the username in the cookie is equal to filename without extension, which is "database", hacker now can direclty download "database.db".

4. Impact of the Vulnerability:
    It is obvious after getting access to database, hackers can now access to all private user data. Furthermore, this web server use a very weak hash algorithm md5, making hackers very easy to brutefroce all the hashed password and getting access to all user's account includes admin account, makeing it feasible to exploit more using admin account.

5. How the Vulnerability was Addressed:
    There are multiple ways to address this problem. 
    * Adding the file extension check
        This is the most easy one, we only need to check whether the file extension is csv or json, we can eliminate this vulnerability here.

    * Using signed cookie to store the filename
        The normal procedure for a user to download the message file is user should firstly pick a format of message, then server will get to create the file. Then user will download the file. We can set a new signed cookie which includes the current file chosen by user, then when user is actually download the file, we will directly use the filename from cookie. In this way we can avoid filename been manipulated by hackers.

2. Source Code and Root Cause:
    At line 315, the code is designed to validate the filename during a user's file download request. However, the code only verifies if the filename matches the user's name and neglects to check the file's extension for validity.

3. How the Vulnerability Could be Exploited:
    Malicious actors can exploit this oversight to access "database.db," a file containing messages and users' passwords. Here's a step-by-step breakdown:

        1. The hacker registers a user named "database."
        2. The hacker logs in as the "database" user.
        3. The hacker sends a direct request to the API via "http://localhost:80/download?file=database.db."

    Due to the code's logic, it only compares the username from the cookie to the filename (sans extension). This allows the hacker to directly access and download "database.db."

4. Impact of the Vulnerability:
    Once hackers access the database, they can retrieve all private user data. Additionally, given that the web server uses the weak MD5 hashing algorithm, it's relatively easy for attackers to brute force all the hashed passwords. This could potentially allow unauthorized access to all user accounts, including the admin account, thus hackers could use admin account for further exploitation.

5. How the Vulnerability was Addressed:
    Multiple mediation approaches exist:

        * File Extension Check: 
            This straightforward fix involves ensuring the file extension is either CSV or JSON, thereby mitigating the vulnerability.

        * Use of Signed Cookies to Store the Filename: 
            Typically, a user chooses a message format (CSV or JSON) before downloading. When user click download button, the server firstly generates the message file with chosen format. Then user can download the file based on the filename. The key point here is that we can ensure that message file generated by server is safe. Therefore we can ensure the download api is safe if user only can download the message file that generated by server. Therefore after server generated message file, we can set the safe filename in users cookie, and then referencing this cookie during the actual download, it removes opportunities for filename manipulation by malicious actors because the filename is signed by server.
 


Vulnerability 4

1. Type: Command injection 

2. Source Code and Root Cause:
    Line 147: os.system(f"rm -f {filename}")

    Line 147 uses the `os.system` method combined with string manipulation to remove files. This allows malicious actors an opportunity to inject commands for the filename.

3. How the Vulnerability Could be Exploited:
    To exploit this vulnerability and inject malicious code into the server's `app.html` file (altering the view for every user), attackers can:

    1. Obtain admin account access, as detailed in vulnerability 3.
    2. Send a POST request to `http://localhost:80/admin`, embedding the injected command within the form data. The form data is as below: 
        username: none; sed -i 's|<html>|<img src onerror="javascript:alert('\''Hacked!'\'')"\>|' templates/app.html #

        This username value will be userd in the formatted string in line 147, and the final commands that is execute by server is:

        os.system("rm -f none; sed -i 's|<html>|<img src onerror="javascript:alert('\''Hacked!'\'')"\>|' templates/app.html #.csv") 
            and
        os.system("rm -f none; sed -i 's|<html>|<img src onerror="javascript:alert('\''Hacked!'\'')"\>|' templates/app.html #.json") 

    The last file extension is added by server since the original code is to delete all the file of provided filename with json and csv extension.

    3. Ultimately, the executed command can add a malicious `<img>` HTML tag before the `<html>` tag. This triggers an alert for every user accessing the `app.html` file at the root endpoint.

4. Impact of the Vulnerability:

    This vulnerability allows command injection, which can perform any action that `system.os` can execute. The potential harm includes file deletion, data alteration, and even server container destruction.

5. How the Vulnerability was Addressed:
    We should not direclty use os.system to execute commands. We should use dedicated python library to safely delete a file. For instance, we can change line 147 to:

        os.remove(filename)

Vulnerability 5
1. Type:  
    Broken Authentication -- Command Injection

2. Source Code and Root Cause:
    Line 174: user = request.form['username']

    This line assigns the username directly from the form data. The username is then used in a manner that allows it to be executed directly by `system.os`, as referenced in vulnerability 4. Because this input is unsanitized, it introduces a command injection risk. Additionally, given that an administrator should not have direct command execution privileges on the server, it represents a broken authentication vulnerability.

3. How the Vulnerability Could be Exploited:
    The lack of input sanitization means that an attacker can leverage this vulnerability to execute command injection as detailed in vulnerability 4. The exploitation process mirrors that described for vulnerability 4.


4. Impact of the Vulnerability:
    Attackers exploiting this vulnerability can execute malicious commands. Potential outcomes include file deletion or alteration, as well as compromising the entire server container.



5. How the Vulnerability was Addressed:
    Directly utilizing the admin-provided username without any sanitization is dangerous. A preferable approach is to first verify the username against the database. Since we sanitize all usernames upon user registration, checking against this known list ensures that only sanitized usernames are used.

    We can add following codes:

        connection = sqlite3.connect("database.db")
        sql = "SELECT username,password,login_attempts FROM users WHERE username=?;"
        cursor = connection.cursor()
        cursor.execute(sql,[username])
        result = cursor.fetchall()
        connection.close()

        # Check whether the username is in database 
        if len(result) != 0: 
    By ensuring that the provided username matches an entry in the sanitized database, the vulnerability can be effectively mitigated.